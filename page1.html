<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two Earths WebGL Demo</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"> <!-- Google Fonts 링크 -->
    <style>
        html, body {
            padding: 0;
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: black;
            font-family: 'Press Start 2P', cursive; /* 폰트 적용 */
        }

        h1 {
            font-size: 18px;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #frame {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80vw;
            height: 80vh;
            border: 3px solid limegreen;
            transform: translate(-50%, -50%);
            box-sizing: border-box;
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .control-button {
            background-color: limegreen;
            border: none;
            color: black;
            padding: 5px 15px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 3px;
        }

        .control-button:active {
            background-color: darkgreen;
        }

        #observation-details {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: limegreen;
            text-align: center;
            font-size: 16px;
            z-index: 10;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: limegreen;
            text-align: center;
            font-size: 16px;
            z-index: 20;
            display: none;
        }

    </style>
</head>
<body>
    <h1 id="header" style="position: absolute; top: 0; width: 100%; text-align: center; color: white; z-index: 10;">
        If parallel worlds were to collide, what would happen? </br> Zoom out to find out something
    </h1>

    <canvas id="scene"></canvas>
    <div id="frame"></div>
    <div id="controls">
        <button id="zoomIn" class="control-button">+</button>
        <button id="zoomOut" class="control-button">-</button>
        <button id="capture" class="control-button">Capture</button>
    </div>
    <div id="observation-details">Observation Date: N/A - Location: N/A</div>
    <div id="message"></div>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import {
          EffectComposer,
          Pass,
          FullScreenQuad
        } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/postprocessing/RenderPass.js';
        import { LensDistortionPassGen } from 'https://cdn.jsdelivr.net/gh/ycw/three-lens-distortion@1.0.0/src/index.js';
        import { DualBloomPassGen } from 'https://cdn.jsdelivr.net/gh/ycw/three-dual-bloom@1.1.6/src/index.js';
        import * as topojson from 'https://cdn.skypack.dev/topojson@3';

        document.addEventListener('DOMContentLoaded', () => {
            class App {
                constructor({ canvas }) {
                    this.canvas = canvas;
                    this.sizes = {
                        viewport: {
                            width: window.innerWidth,
                            height: window.innerHeight
                        }
                    };

                    this.init();
                }

                async init() {
                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0x000000);

                    // 카메라 설정
                    this.camera = new THREE.PerspectiveCamera(70, this.sizes.viewport.width / this.sizes.viewport.height, 1, 1000);
                    this.camera.position.z = 5;

                    // 렌더러 설정
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: this.canvas,
                        antialias: true
                    });
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    this.renderer.setSize(this.sizes.viewport.width, this.sizes.viewport.height);
                    window.addEventListener('resize', () => this.handleResize(), { passive: true });

                    // 카메라 컨트롤 설정
                    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enablePan = false;
                    this.controls.enableZoom = false;

                    // 원본 지구본 생성
                    this.originalEarth = await this.createEarth(0xffffff, 0);
                    this.scene.add(this.originalEarth);

                    // 파란색 지구본 생성
                    this.blueEarth = await this.createEarth(0x0000ff, 10); // 더 멀리 배치
                    this.scene.add(this.blueEarth);

                    // 줌 인/아웃 버튼 이벤트 핸들러 추가
                    this.addZoomControls();

                    // 캡처 버튼 이벤트 핸들러 추가
                    this.addCaptureButton();

                    // 파란 지구 클릭 이벤트 핸들러 추가
                    this.blueEarth.userData = { clickable: false }; // 초기 상태에서 클릭 불가능
                    this.canvas.addEventListener('click', this.onCanvasClick.bind(this));

                    // 포스트 프로세싱 효과 설정
                    this.initPostProcessing();

                    this.render();
                }

                async createEarth(color, xPosition) {
                    const response = await fetch("https://cdn.jsdelivr.net/npm/world-atlas@1/world/50m.json");
                    const topology = await response.json();
                    const mesh = topojson.mesh(topology, topology.objects.land);
                    const material = new THREE.LineBasicMaterial({ color: color });
                    const earth = this.wireframe(mesh, 1.25, material);
                    earth.position.set(xPosition, 0, 0);
                    return earth;
                }

                wireframe(multilinestring, radius, material) {
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    for (const P of multilinestring.coordinates) {
                        for (let p0, p1 = this.vertex(P[0], radius), i = 1; i < P.length; ++i) {
                            p0 = p1;
                            p1 = this.vertex(P[i], radius);
                            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
                        }
                    }
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    return new THREE.LineSegments(geometry, material);
                }

                vertex([longitude, latitude], radius) {
                    const lambda = longitude * Math.PI / 180;
                    const phi = latitude * Math.PI / 180;
                    return new THREE.Vector3(
                        radius * Math.cos(phi) * Math.cos(lambda),
                        radius * Math.sin(phi),
                        -radius * Math.cos(phi) * Math.sin(lambda)
                    );
                }

                handleResize() {
                    this.sizes.viewport.width = window.innerWidth;
                    this.sizes.viewport.height = window.innerHeight;
                    this.camera.aspect = this.sizes.viewport.width / this.sizes.viewport.height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.sizes.viewport.width, this.sizes.viewport.height);
                    this.composer.setSize(this.sizes.viewport.width, this.sizes.viewport.height);
                }

                addZoomControls() {
                    const zoomInButton = document.getElementById('zoomIn');
                    const zoomOutButton = document.getElementById('zoomOut');
                    let zoomInInterval, zoomOutInterval;

                    const startZoomIn = () => {
                        zoomInInterval = setInterval(() => {
                            this.camera.position.z -= 0.1;
                            this.controls.update();
                        }, 16);
                    };

                    const stopZoomIn = () => {
                        clearInterval(zoomInInterval);
                    };

                    const startZoomOut = () => {
                        zoomOutInterval = setInterval(() => {
                            this.camera.position.z += 0.1;
                            this.controls.update();
                        }, 16);
                    };

                    const stopZoomOut = () => {
                        clearInterval(zoomOutInterval);
                    };

                    // Mouse events for zoom in button
                    zoomInButton.addEventListener('mousedown', startZoomIn);
                    zoomInButton.addEventListener('mouseup', stopZoomIn);
                    zoomInButton.addEventListener('mouseleave', stopZoomIn);

                    // Touch events for zoom in button
                    zoomInButton.addEventListener('touchstart', startZoomIn);
                    zoomInButton.addEventListener('touchend', stopZoomIn);
                    zoomInButton.addEventListener('touchcancel', stopZoomIn);

                    // Mouse events for zoom out button
                    zoomOutButton.addEventListener('mousedown', startZoomOut);
                    zoomOutButton.addEventListener('mouseup', stopZoomOut);
                    zoomOutButton.addEventListener('mouseleave', stopZoomOut);

                    // Touch events for zoom out button
                    zoomOutButton.addEventListener('touchstart', startZoomOut);
                    zoomOutButton.addEventListener('touchend', stopZoomOut);
                    zoomOutButton.addEventListener('touchcancel', stopZoomOut);
                }

                addCaptureButton() {
                    const captureButton = document.getElementById('capture');
                    captureButton.addEventListener('click', () => {
                        console.log('Camera Zoom Level (Z Position):', this.camera.position.z);
                        if (this.camera.position.z >= 11) {
                            document.getElementById('observation-details').textContent = "CAPTURED";
                            this.blueEarth.userData.clickable = true; // 파란 지구 클릭 가능
                        } else {
                            document.getElementById('observation-details').textContent = "Observation Date: N/A - Location: N/A";
                            this.blueEarth.userData.clickable = false; // 파란 지구 클릭 불가능
                        }
                    });
                }

                onCanvasClick(event) {
                    if (this.blueEarth.userData.clickable) {
                        const mouse = new THREE.Vector2();
                        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                        const raycaster = new THREE.Raycaster();
                        raycaster.setFromCamera(mouse, this.camera);
                        const intersects = raycaster.intersectObject(this.blueEarth);

                        if (intersects.length > 0) {
                            // 파란 지구 클릭됨, 카메라 이동
                            this.camera.position.set(this.blueEarth.position.x, this.blueEarth.position.y, this.blueEarth.position.z + 5);
                            this.controls.target.copy(this.blueEarth.position);
                            this.controls.update();

                            // 이미지 왜곡 효과 적용
                            this.applyDistortionEffect();

                            // UI 요소 비활성화
                            document.getElementById('frame').style.display = 'none';
                            document.getElementById('controls').style.display = 'none';
                            document.getElementById('observation-details').style.display = 'none';
                            document.getElementById('header').style.display = 'none';

                            // 메시지 출력
                            this.typeMessage("can't stop hyperstellar");
                        }
                    }
                }

                initPostProcessing() {
                    const deps = { THREE, Pass, FullScreenQuad };
                    const LensDistortionPass = LensDistortionPassGen(deps);
                    this.lensDistortionPass = new LensDistortionPass({
                        distortion: new THREE.Vector2(-1, -1),
                        focalLength: new THREE.Vector2(2, 2),
                        skew: 0,
                        principalPoint: new THREE.Vector2(0, 0)
                    });
                    this.lensDistortionPass.enabled = false; // 처음에는 비활성화
                    const DualBloomPass = DualBloomPassGen(deps);
                    this.dualBloomPass = new DualBloomPass({
                        threshold: 0.1,
                        blurriness: 4.0,
                        intensity: 5
                    });
                    this.dualBloomPass.enabled = false; // 처음에는 비활성화

                    this.composer = new EffectComposer(this.renderer);
                    this.composer.addPass(new RenderPass(this.scene, this.camera));
                    this.composer.addPass(this.lensDistortionPass);
                    this.composer.addPass(this.dualBloomPass);
                }

                applyDistortionEffect() {
                    this.lensDistortionPass.enabled = true;
                    this.dualBloomPass.enabled = true;
                    this.startAutoCameraMovement();
                }

                typeMessage(message) {
                    const messageElement = document.getElementById('message');
                    if (messageElement) {
                        messageElement.style.display = 'block';
                        messageElement.textContent = '';
                        let index = 0;
                        const interval = setInterval(() => {
                            messageElement.textContent += message[index];
                            index++;
                            if (index === message.length) {
                                clearInterval(interval);
                            }
                        }, 100);
                    } else {
                        console.error("Element with id 'message' not found.");
                    }
                }

                startAutoCameraMovement() {
                    const movementSpeed = 0.0025;
                    let elapsedTime = 0;
                    const duration = 5000; // 5초 동안
                    const initialZ = 5;
                    const targetZ = 0;

                    const moveCamera = () => {
                        if (elapsedTime < duration) {
                            this.camera.rotation.y += movementSpeed;
                            const progress = elapsedTime / duration;
                            this.camera.position.z = initialZ * (1 - progress) + targetZ * progress;
                            elapsedTime += 16; // 약 60fps 기준
                            requestAnimationFrame(moveCamera);
                        } else {
                            this.camera.position.z = targetZ; // Ensure final position is exact
                            window.location.href = 'page3.html'; // 5초 후 페이지 이동
                        }
                    };

                    requestAnimationFrame(moveCamera);
                }

                render() {
                    requestAnimationFrame(() => this.render());
                    if (this.originalEarth) {
                        this.originalEarth.rotation.y += 0.01;
                    }
                    if (this.blueEarth) {
                        this.blueEarth.rotation.y += 0.01;
                    }
                    this.controls.update();
                    this.composer.render();
                }
            }

            new App({ canvas: document.querySelector("#scene") });
        });
    </script>
</body>
</html>
