<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earth WebGL Demo</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"> <!-- Google Fonts 링크 -->
    <style>
        html, body {
            padding: 0;
            font-family: 'Press Start 2P', cursive; /* 폰트 적용 */
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: black;
        }

        h1 {
            font-size: 12px;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        #frame {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80vw;
            height: 80vh;
            border: 3px solid limegreen;
            transform: translate(-50%, -50%);
            box-sizing: border-box;
            pointer-events: none; /* Ensure clicks pass through to canvas */
        }

        #observation-details {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: limegreen;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <h1 id="header" style="position: absolute; top: 0; width: 100%; text-align: center; color: white; z-index: 10;">
        If parallel worlds were to meet, what would happen? </br> zoom out to find out something
    </h1>

    <canvas id="scene"></canvas>
    <div id="frame"></div>
    <div id="observation-details">Observation Date: N/A - Location: N/A</div>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import * as topojson from 'https://cdn.skypack.dev/topojson@3';

        document.addEventListener('DOMContentLoaded', () => {
            class App {
                constructor({ canvas }) {
                    this.canvas = canvas;
                    this.init().then(response => {
                        this.land = response;
                        this.scene = new THREE.Scene();
                        this.scene.background = new THREE.Color(0x000000);
                        this.scene.add(this.land);
                        this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
                        this.camera.position.z = 10; // 카메라의 위치를 좀 더 멀리 설정
                        this.renderer = new THREE.WebGLRenderer({
                            canvas: this.canvas,
                            antialias: true
                        });
                        this.renderer.setPixelRatio(window.devicePixelRatio);
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        window.addEventListener('resize', () => this.handleResize(), { passive: true });

                        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                        this.controls.enablePan = true;
                        this.controls.enableZoom = true;
                        this.controls.maxDistance = 50; // 최대 줌 아웃 거리 확장
                        this.controls.minDistance = 1;

                        this.render();
                    });
                }

                async init() {
                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0x000000);

                    const response = await fetch("https://cdn.jsdelivr.net/npm/world-atlas@1/world/50m.json");
                    const topology = await response.json();
                    const mesh = topojson.mesh(topology, topology.objects.land);

                    // 원본 지구 생성
                    const originalEarth = this.wireframe(mesh, 1.25, new THREE.LineBasicMaterial({ color: 0xffffff }));
                    this.scene.add(originalEarth);

                    // 복제된 지구 생성 및 위치 조정
                    const clonedEarth = originalEarth.clone();
                    clonedEarth.scale.set(0.25, 0.25, 0.25);  // 크기를 원본의 4분의 1로 조정
                    clonedEarth.position.x = 2.5;  // X축 거리를 원본의 2배 떨어지게 조정
                    this.scene.add(clonedEarth);

                    this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
                    this.camera.position.z = 15; // 카메라 초기 위치 조정
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: this.canvas,
                        antialias: true
                    });
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    this.renderer.setSize(window.innerWidth, window.innerHeight);

                    return originalEarth;
                }

                wireframe(multilinestring, radius, material) {
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    for (const P of multilinestring.coordinates) {
                        for (let p0, p1 = this.vertex(P[0], radius), i = 1; i < P.length; ++i) {
                            p0 = p1;
                            p1 = this.vertex(P[i], radius);
                            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
                        }
                    }
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    return new THREE.LineSegments(geometry, material);
                }

                vertex([longitude, latitude], radius) {
                    const lambda = longitude * Math.PI / 180;
                    const phi = latitude * Math.PI / 180;
                    return new THREE.Vector3(
                        radius * Math.cos(phi) * Math.cos(lambda),
                        radius * Math.sin(phi),
                        -radius * Math.cos(phi) * Math.sin(lambda)
                    );
                }

                render() {
                    requestAnimationFrame(() => this.render());
                    this.land.rotation.y += 0.0025;
                    this.controls.update();
                    this.renderer.render(this.scene, this.camera);
                }

                handleResize() {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            new App({ canvas: document.querySelector("#scene") });
        });
    </script>
</body>
</html>
