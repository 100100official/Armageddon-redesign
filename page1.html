<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earth WebGL Demo</title>
    <style>
        html,
        body {
            padding: 0;
            margin: 0;
            height: 100%;
        }

        canvas {
            display: block;
        }

        button {
            position: absolute;
            bottom: 28px;
            right: 28px;
            opacity: 0;
        }
    </style>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import { GLTFExporter } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/exporters/GLTFExporter.js';
        import * as topojson from 'https://cdn.skypack.dev/topojson@3';

        document.addEventListener('DOMContentLoaded', () => {
            class App {
                constructor({ canvas, cta }) {
                    this.sizes = {
                        viewport: {
                            width: document.body.offsetWidth,
                            height: document.body.offsetHeight
                        }
                    };
                    this.radius = 1.25;
                    this.init().then(response => {
                        this.land = response;

                        this.scene = new THREE.Scene();
                        this.scene.background = new THREE.Color(0x000000);

                        this.scene.add(this.land);

                        this.camera = new THREE.PerspectiveCamera(
                            70,
                            this.sizes.viewport.width / this.sizes.viewport.height,
                            1,
                            1000
                        );
                        this.camera.position.z = 3;
                        this.renderer = new THREE.WebGLRenderer({
                            canvas: canvas,
                            alpha: false,
                            stencil: false,
                            depth: false,
                            powerPreference: "high-performance",
                            antialias: true
                        });
                        cta.addEventListener('click', () => {
                            this.exportGLTF(this.scene);
                        });
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        this.handleResize();
                        window.addEventListener('resize', () => this.handleResize(), { passive: true });

                        // Add OrbitControls for zooming and panning
                        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                        this.controls.enablePan = true;
                        this.controls.enableZoom = true;
                        this.controls.maxDistance = 10;
                        this.controls.minDistance = 1;

                        this.render();

                        // Add event listener to canvas for page navigation
                        canvas.addEventListener('dblclick', () => {
                            window.location.href = 'page2.html';
                        });
                    });
                }

                async init() {
                    const response = await fetch(
                        "https://cdn.jsdelivr.net/npm/world-atlas@1/world/50m.json"
                    );
                    const topology = await response.json();
                    const mesh = topojson.mesh(topology, topology.objects.land);
                    return this.wireframe(
                        mesh,
                        this.radius,
                        new THREE.LineBasicMaterial({ color: 0xffffff })
                    );
                }

                vertex([longitude, latitude], radius) {
                    const lambda = longitude * Math.PI / 180;
                    const phi = latitude * Math.PI / 180;
                    return new THREE.Vector3(
                        radius * Math.cos(phi) * Math.cos(lambda),
                        radius * Math.sin(phi),
                        -radius * Math.cos(phi) * Math.sin(lambda)
                    );
                }

                wireframe(multilinestring, radius, material) {
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];

                    for (const P of multilinestring.coordinates) {
                        for (let p0, p1 = this.vertex(P[0], radius), i = 1; i < P.length; ++i) {
                            const pt1 = (p0 = p1);
                            const pt2 = (p1 = this.vertex(P[i], radius));
                            vertices.push(pt1.x, pt1.y, pt1.z, pt2.x, pt2.y, pt2.z);
                        }
                    }

                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    return new THREE.LineSegments(geometry, material);
                }

                render() {
                    requestAnimationFrame(() => this.render());
                    this.land.rotation.y += 0.0025;
                    this.controls.update();  // Update controls
                    this.renderer.render(this.scene, this.camera);
                }

                handleResize() {
                    this.sizes.viewport.width = document.body.offsetWidth;
                    this.sizes.viewport.height = document.body.offsetHeight;
                    this.camera.aspect = this.sizes.viewport.width / this.sizes.viewport.height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(
                        this.sizes.viewport.width,
                        this.sizes.viewport.height
                    );
                }

                exportGLTF(scene) {
                    // Export the scene as GLTF
                    const exporter = new GLTFExporter();
                    exporter.parse(scene, function (result) {
                        const output = JSON.stringify(result, null, 2);
                        console.log(output);
                        saveString(output, 'scene.gltf');
                    });

                    function saveString(text, filename) {
                        const blob = new Blob([text], { type: 'text/plain' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = filename;
                        link.click();
                    }
                }
            }

            new App({
                canvas: document.body.querySelector("#scene"),
                cta: document.body.querySelector("button")
            });
        });
    </script>
</head>
<body>
    <canvas id="scene"></canvas>
    <button>Export</button>
</body>
</html>
