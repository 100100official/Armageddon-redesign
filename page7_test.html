<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Distortion Effect</title>
    <style>
        body {
            overflow: hidden;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #container {
            position: fixed;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="container"></div>
    <script type="module">
        import * as THREE from 'three';

        let container;
        let camera, scene, renderer;
        let uniforms;

        init();
        animate();

        function init() {
            container = document.getElementById('container');

            camera = new THREE.Camera();
            camera.position.z = 1;

            scene = new THREE.Scene();

            const geometry = new THREE.PlaneGeometry(2, 2);

            uniforms = {
                u_time: { type: 'f', value: 1.0 },
                u_resolution: { type: 'v2', value: new THREE.Vector2() },
                u_mouse: { type: 'v2', value: new THREE.Vector2() },
                u_image: { type: 't', value: new THREE.TextureLoader().load('src/aespa001.png') },
                u_distortionCenter: { type: 'v2', value: new THREE.Vector2(Math.random(), Math.random()) },
                u_distortionRadius: { type: 'f', value: 0.3 }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            onWindowResize();
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize(event) {
            uniforms.u_resolution.value.x = renderer.domElement.width;
            uniforms.u_resolution.value.y = renderer.domElement.height;
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            uniforms.u_time.value += 0.05;
            renderer.render(scene, camera);
        }
    </script>

    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4(position, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec2 u_mouse;
        uniform sampler2D u_image;
        uniform vec2 u_distortionCenter;
        uniform float u_distortionRadius;

        float tri(float x) { return abs(fract(x) - 0.5); }

        float triNoise2D(vec2 p) {
            const mat2 m2 = mat2(0.75, 1.2990381, -1.2990381, 0.75);
            float n = tri(p.x + tri(p.y * 0.5 + 0.3333)) + tri(p.y + tri(p.x * 0.5 - 0.1666));
            p *= m2;
            n += (tri(p.x + tri(p.y * 0.5 + 0.3333)) + tri(p.y + tri(p.x * 0.5 - 0.1666))) * 0.7071;
            p *= m2;
            n += (tri(p.x + tri(p.y * 0.5 + 0.3333)) + tri(p.y + tri(p.x * 0.5 - 0.1666))) * 0.5;
            return n / (2.2071);
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            vec4 color = texture2D(u_image, uv);

            // 랜덤한 왜곡 중심과 반경 내에서 왜곡 효과 적용
            float dist = distance(uv, u_distortionCenter);
            if (dist < u_distortionRadius) {
                float effectStrength = (u_distortionRadius - dist) / u_distortionRadius;
                uv.x += sin(u_time + uv.y * 10.0) * effectStrength * 0.1;
                uv.y += cos(u_time + uv.x * 10.0) * effectStrength * 0.1;
                color.rgb = mix(color.rgb, vec3(1.0, 0.0, 1.0), effectStrength); // 보라색으로 변형
            }

            gl_FragColor = color;
        }
    </script>
</body>
</html>
