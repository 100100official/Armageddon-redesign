<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page 5</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
        }
        .volume-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: space-around;
            width: 80%;
        }
        .volume-controls input[type="range"] {
            writing-mode: vertical-lr; /* Vertical */
        }
    </style>
</head>
<body>
    <div class="volume-controls">
        <input type="range" min="0" max="1" step="0.01" value="0" id="volume1" style="writing-mode: vertical-lr;">
        <input type="range" min="0" max="1" step="0.01" value="0" id="volume2" style="writing-mode: vertical-lr;">
        <input type="range" min="0" max="1" step="0.01" value="0" id="volume3" style="writing-mode: vertical-lr;">
        <input type="range" min="0" max="1" step="0.01" value="0" id="volume4" style="writing-mode: vertical-lr;">
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, plane, floor, pointLight, ambientLight, composer;
        let drumVolumeControl;

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 40, 45); // 카메라를 적절한 위치로 설정
            camera.lookAt(0, 20, 0); // 카메라가 원점을 바라보도록 설정

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create the plane with glow effect
            const planeGeometry = new THREE.PlaneGeometry(40, 40);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.position.y = 20; // 바닥에서 떠있도록 설정
            plane.rotation.x = Math.PI / 2; // 바닥에 평평하게 놓이도록 회전
            scene.add(plane);

            // Create the floor
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = 0; // 바닥의 위치를 y=0으로 설정
            floor.rotation.x = Math.PI / 2; // 바닥이 평평하게 놓이도록 회전
            scene.add(floor);

            // Add lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            pointLight = new THREE.DirectionalLight(0xffffff, 1);
            pointLight.position.set(1, 1, 1).normalize();
            scene.add(pointLight);

            // Create stars
            function createStars() {
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.PointsMaterial({ color: 0xffffff });

                const starVertices = [];
                for (let i = 0; i < 10000; i++) {
                    const x = THREE.MathUtils.randFloatSpread(2000);
                    const y = THREE.MathUtils.randFloatSpread(2000);
                    const z = THREE.MathUtils.randFloatSpread(2000);
                    starVertices.push(x, y, z);
                }

                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

                const stars = new THREE.Points(starGeometry, starMaterial);
                scene.add(stars);
            }

            // Call the createStars function
            createStars();

            // Post-processing for glow effect
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.6,   // Strength
                0.2,   // Radius
                0.1    // Threshold
            );

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Audio setup
            setupAudio();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            plane.rotation.z += 0.01; // 판을 회전하도록 설정
            composer.render();

            // Optional: Make stars twinkle
            scene.children.forEach(child => {
                if (child instanceof THREE.Points) {
                    child.rotation.y += 0.001; // 별들을 천천히 회전시켜 반짝이는 효과
                }
            });
        }

        function setupAudio() {
            const audioSources = [
                'supernova/Supernova_bass.mp3',
                'supernova/Supernova_drum.mp3',
                'supernova/Supernova_vocal.mp3',
                'supernova/Supernova_other_inst.mp3'
            ];

            let audioContext;
            const audioElements = audioSources.map(src => {
                const audio = new Audio(src);
                audio.crossOrigin = "anonymous";
                audio.loop = true;
                return audio;
            });

            document.body.addEventListener('click', () => {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    audioElements.forEach(audio => audio.play());

                    // Setup distortion and volume controls
                    setupDistortionAndVolume(audioContext, audioElements);
                }
            }, { once: true });
        }

        function setupDistortionAndVolume(audioContext, audioElements) {
            const gainNodes = [];
            const distortionNodes = [];
            drumVolumeControl = document.getElementById('volume2');

            function createDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50;
                const n_samples = 44100;
                const curve = new Float32Array(n_samples);
                const deg = Math.PI / 180;
                for (let i = 0; i < n_samples; ++i) {
                    const x = i * 2 / n_samples - 1;
                    curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }

            function setDistortion(audioElement, volumeControl, index) {
                const source = audioContext.createMediaElementSource(audioElement);
                const gainNode = audioContext.createGain();
                const distortion = audioContext.createWaveShaper();

                distortion.curve = createDistortionCurve(50); // 디스토션 강도 조절
                distortion.oversample = '2x'; // 디스토션 오버샘플링 줄임

                source.connect(gainNode);
                gainNode.connect(distortion);
                distortion.connect(audioContext.destination);

                gainNode.gain.value = 0; // 초기 볼륨을 0으로 설정

                gainNodes[index] = gainNode;

                volumeControl.addEventListener('input', event => {
                    const volume = event.target.value;
                    gainNode.gain.value = volume * 0.5; // 전체 최대 음량을 제한
                    if (volume > 0.8) {
                        gainNode.disconnect();
                        gainNode.connect(distortion);
                    } else {
                        gainNode.disconnect();
                        gainNode.connect(audioContext.destination);
                    }
                });
            }

            setDistortion(audioElements[0], document.getElementById('volume1'), 0);
            setDistortion(audioElements[1], document.getElementById('volume2'), 1);
            setDistortion(audioElements[2], document.getElementById('volume3'), 2);
            setDistortion(audioElements[3], document.getElementById('volume4'), 3);
        }
    </script>
</body>
</html>







<!-- python -m http.server -->
<!-- http://localhost:8000 -->
 <!-- npx vite -->